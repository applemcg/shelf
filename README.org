#+INCLUDE: ./universalOrgPreface.txt

#+TITLE: Shelflib -- User Guide to SHELF practice

* COMMENT TODO

** TODO add OrgMode output format 
   from shdoc for HTML function ref!  for which i thank the shdoc
   work: ~/src/shdoc from '09 this implies a LITTLE language to
   control side-effects
** TODO follow shdoc link 
   when this work challenges simon laube's use, and is sufficient to
   present to him.  what should hte name be?

* Scope

This library supports the [[./shelf.org][SHELF Standard]].  Since the the SHELF
Standard uses /function families/, this is the User Guide for the
/shelflib/.  As such it introduces four function families and a
utility group of functions.  Each of these five (four familes, one
group) have their own User Guide,

The /function family/ introduces nothing new to shell syntax or
ability to access function libraries.  It does set a practice to
organize function collections inside a function library.

From a practical stand point, each family or group has its own source
file.  These are combined into a single shell library ~shelflib~
and installed in the user's runtime.   Instructions follow.

When installed, the user has roughly 80 bash shell functions to 
extend the practice to their own work.

If you have not yet read the  [[./shelf.org][SHELF Standard]], now would be a good
time before proceeding.

* Families

These are the four families and utility group of functions.  Each
section introduces the family or group to indentify it's distinct
purpose in support of the [[./shelf.org][SHELF Standard]].  The next section introduces
the respective User Guides.

** fam --   the family model for naming functions

The *fam* family generates the framework to define a function family.
To define a family, call the main entry point:

:   ... fam_iam    # Family, I am

from an intialization function.  This establishes the family
framework.   For example, the *fam* family instantiates itself
as a family thusly:

: fam_init () { fam_iam; ... other initialization; }
: ...
: fam_init 1>&2;    # if the only family in a library

To see how multiple families are collected in a single library,
see the discussion on [[mflibinit][Multi-family libraries]].

** report -- or *assert* for verifying function arguments

A reporting function is used in a shell function to assert its
arguments as to number, type of file, or string length, or any
assertion you can support with a function.

A typical use of an assertion:

: report_not{something} $1 && return N

where N is usually a 1, ... the number of an error return from the
user function, and "something" is /readable, writable, executable/,
....

Here is a sample function.

: function report_notreadable
: { 
:     [[ -r $1 ]] && return 1;
:     report_usage $1 is NOT readable
: }
Since this function does not test it's own arugment count (does 
it indeed have an argument, it's best used following a test to 
verify the argument exists.

: ... 
: report_notargcount 2 $# flag file && return 1
: report_notreadable $2 && return 2

for example, where *report_notargcount* is:

#+BEGIN_SRC 
report_notargcount () 
{ 
    [[ $2 -ge $1 ]] && return 1;
    report_usage need at least $1 arg/s: $(shift 2; echo $*)
}
#+END_SRC

Note how the function treats arguments after the second.  Woe to the
user who abuses a reporting function.

In the examples above, a positive statement asserts an argument isn't
something, and return a failure when that's the case.  So, the user
function lines up as many assertions on it's arguments as needed.  The
first one to fail produces the required message and returns from the
function with a message on /stderr/ from *report_usage*.  Otherwise
the function executes as desired.

** shdoc -- the SHell DOCumentation standard

These functions encourage a programmer to write a brief introductory
user guide to each function.  Here is the [[./shdoc.org][shdoc Family User Guide]].

The family name is the *shd* prefix.  The functions in this family set
a standard for  shell doclib capture and  presentation.  Precedent for
the practice  was first  established by [[https://en.wikipedia.org/wiki/Javadoc][Javadoc]]  and more  recently in
[[https://en.wikipedia.org/wiki/Plain_Old_Documentation][Perldoc]] and [[https://en.wikipedia.org/wiki/Pydoc][Pydoc]].

A majority of online references to  "shdoc" are few and disjoint.  The
most common reference to an [[http://mirror.unl.edu/ctan/macros/latex/contrib/shdoc/shdoc.pdf][shdoc package]] is a tool kit for caputuring
command line usage and is built for the TeX community.

** trace -- function execution tracing, and

The tracing feature of these shell functions uses /trace_call/ in a
function body after some assertion validation using the *report*
functions.  While it's not dependent on all assertions passing, it
seems useful to dispose of the assertions, which announce a failure,
and then announce the function body is ready to work.

Tracing my be enabled or disabled, by /trace_on/ or /trace_off/. 
Either of them reset the function behavior to either /trace_stderr/,
or simply /return/, respectively.

At bottom, the tracing logs it's calls to a per-user file:

: HOME/lib/trace.log

and echo's each call to the *stderr*, which may be separately saved
or altogether ignored:

: ... 2> trace.err    # say, or
: ... 2> /dev/null    # the "bit-bucket"

In any case, while tracing is enabled, the /logDateOnceHourly/
function inspects the latest entry in the log to see if it's time to
post a new HOUR mark.  I felt it useful to collect usage at this
level, anticipating collecting function usage statistics.  On
reflection, the necessary test for the last record might be more work
than necessary.  I've done some work elsewhere, to collect the hourly
work by number of command executions.

For each call, the trace log collects two function names: the current
function and it's calling function.  This enables a user to construct
a calling tree from the log.

** util -- a few programming functions

These are generic functions, not worth finding a family to call home.
Such names as /foreach/, /ignore/, /comment/, /functions/, ...

As such, their inclusion in the collecting library was simply to
satisfy one requirement: that no function in the library refer to a
function not in the library.

* User Guides

When the families and utility group are combined in a single library,
no function refers to a function not in the library.  

These are listed in order of encounter. 

+ [[./famguide.org][Family User Guide]]

** fam family
** report family
*** reportlib, main

And here is the ~report~ function family.

First a copyright, then the initialization function.  Since this 
is a /family/, the only necessary call is to *fam_iam*

#+BEGIN_SRC sh :tangle ./inc/report.0 :comments link :padline no
copyright_report () 
{ 
    comment "Copyright (C) 2015-2016, JYATL - Just Yet Another Testing Lab";
    comment "mailto: mcgowan (at) alum DOT mit DOT edu";
}
report_init ()
{
    fam_iam
}
@include report.1
report_init 1>&2

#+END_SRC

*** reportlib, working

Then here are the working functions.

#+BEGIN_SRC sh :tangle ./inc/report.1 :comments link :padline no
function report_emptyfile
{ 
    [[ -s $1 ]] && return 1;
    report_usage File: is empty
}
function report_isfile
{ 
    [[ -f $1 ]] || return 1;
    report_usage $1 IS a file and should not be
}
function report_needcount
{ 
    [[ $2 -ge $1 ]] && return 1;
    usage need at least $1 arg/s $(shift 2; echo $*)
}
function report_notbase
{ 
    [[ $(basename $PWD) == "$1" ]] && return 1;
    comment change to "$1" directory
}
function report_notblockspecial
{ 
    [[ -b $1 ]] && return 1;
    report_usage $1 is NOT a blockspecial file
}
function report_notcalledby
{ 
    set ${1:-/dev/null} $(myname 3) non-Existant-function;
    [[ $2 == $1 ]] && return 1;
    report_usage was NOT called by $1.
}
function report_notcharacterspecial
{ 
    [[ -c $1 ]] && return 1;
    report_usage $1 is NOT a characterspecial file
}
function report_notdirectory
{ 
    [[ -d $1 ]] && return 1;
    report_usage $1 is NOT a Directory
}
function report_notexecutable
{ 
    [[ -x $1 ]] && return 1;
    report_usage $1 is NOT an executable file
}
function report_notexisting
{ 
    [[ -e $1 ]] && return 1;
    report_usage $1 is NOT an existing file
}
function report_notfunction
{ 
    set ${1:-/dev/null};
    isfunction $1 && return 1;
    report_usage $1 is NOT a Function
}
function report_notgroupiseuid
{ 
    [[ -G $1 ]] && return 1;
    report_usage $1 is NOT a file with groupiseuid
}
function report_notlargeenough
{ 
    [[ $2 -ge $1 ]] && return 1;
    report_usage $1 $(echo 1 $1, 2 $2 $(shift 2; echo $*))
}
function report_notnonzerostring
{ 
    [[ -n $1 ]] && return 1;
    report_usage $1 is NOT a nonzerolengthstring
}
function report_notowneriseuid
{ 
    [[ -O $1 ]] && return 1;
    report_usage $1 is NOT a file with owneriseuid
}
function report_notpipe
{ 
    [[ -p /dev/stdin ]] && return 1;
    report_usage is NOT reading a pipe
}
function report_notreadable
{ 
    [[ -r $1 ]] && return 1;
    report_usage $1 is NOT a readable file
}
function report_notsetgroupid
{ 
    [[ -g $1 ]] && return 1;
    report_usage $1 is NOT a file with setgroupid
}
function report_notsetuserid
{ 
    [[ -u $1 ]] && return 1;
    report_usage $1 is NOT a file with setuserid
}
function report_notsocket
{ 
    [[ -S $1 ]] && return 1;
    report_usage $1 is NOT a socket
}
function report_notstickybitset
{ 
    [[ -k $1 ]] && return 1;
    report_usage $1 is NOT a file with its stickybitset
}
function report_notsymboliclink
{ 
    [[ -L $1 ]] && return 1;
    report_usage $1 is NOT a symboliclink
}
function report_notwritable
{ 
    [[ -w $1 ]] && return 1;
    report_usage $1 is NOT a writable file
}
function report_notzerolengthstring
{ 
    [[ -z $1 ]] && return 1;
    report_usage $1 is NOT a zerolengthstring
}
function report_usage
{ 
    comment USAGE $(myname 3): $*
}
report_functions () 
{ 
    set | awk '$2 ~ /\(\)/ { print $1 }' | grep '^report_'
}
report_nofilefrom () 
{ 
    set $(eval $*) /dev/null $*;
    [[ -f $1 ]] && return 1;
    shift;
    report_usage \'$*\' did not return a file name.
}
report_notargcount () 
{ 
    [[ $2 -ge $1 ]] && return 1;
    report_usage need at least $1 arg/s: $(shift 2; echo $*)
}
report_notcommand () 
{ 
    ignore type -a $1 && return 1;
    report_usage $1 is NOT a command
}
report_notfile () 
{ 
    [[ -f $1 ]] && return 1;
    report_usage $1 is NOT a file
}
report_notfilegreaterthanzero () 
{ 
    [[ -s $1 ]] && return 1;
    report_usage $1 is NOT a filegreaterthanzero
}
report_nottrue () 
{ 
    eval "$@" && return 1;
    report_usage $@ FAILED
}
#+END_SRC

*** COMMENT tangles 


#+BEGIN_SRC sh :tangle ./inc/util.0 :comments both :padline no

#+END_SRC

** shdoc family
** trace family

** utility functions
   
Note the shell idiom in the *shd_top* function.   It's a convenient 
shorthand to list a collection of similar names.  In this case, this
/shdlib/ conventionally defines functions whose name begins with /shd_/.

#+BEGIN_SRC sh :tangle ./inc/shdoc.3 :comments both :padline no
shd_top () 
{ 
    echo shdoc shd_{oc,each,with,test}
}
shd_test () 
{ 
    : 1. test default, NO arguments, then;
    : 2. stub out test all functions in the library;
    : 3. demonstrate ignore subsequent comments;
    : 4. test shd_with;
    : 5. test shd_each defends against non-shdoc call;
    shdoc;
    :;
    set $(sfg shd_);
    : doit shdoc $*;
    shd_with $*;
    shd_each $*;
    declare -f shd_test | grep -v '^ *:' 1>&2
}
#+END_SRC 

The standard  practice for such  a family has the  executable ~fam_iam~
which establishes the function family  of functions sharing the common
preface.

For example:

: $ shd top       # calls shd_top, returning
: shdoc shd_oc shd_each shd_with shd_test

#+NAME: mflibinit
* Multi-family libraries

The [[./shelf.org][SHELF Standard]] allows a single executable statment when sourceing
a library, which leaves nothing on the standard output.  Since each family
has it's own initialization function, it is only necessary for the library
to invoke the separate familiy initialization.   For the ~shelflib~ this 
is how it happens:
#+BEGIN_SRC
shelf_init ()
{
    fam_init
    report_init
    shdoc_init
    trace_init
}
shelf_init 1>&2
#+END_SRC
as the last code in the shelf library.  Presumably the utility
functions do not need initialization, or they too would be a family.

* Historical note

This library was originally built from a single, tangled, OrgMode source file.
In order to make the files accessible to the general audience, the de-tangled 
files are now the source control objects, and therefore available for edit in 
their own individual right.

To that end, while the separate files are now combined into a single library,
the process which supported that process, and at this moment, 
the [[http://github.com/applemcg/combine][Combine Repository]] is itself being brought into this REPO and resulting
SHELF library. 
** The installation script
Given the companion [[./combine.org][Combine facility]], this is the install script for the
shelflib:

#+INCLUDE: "./src/shelflib.install"

** the top shelf

The shelf.all file collects the families into the installable
shell library: *shelflib*
#+INCLUDE: "./inc/shelf.all" example

And it's initialized by the only unique function in the library:
~shelf_init~ which initializes the various families:

#+INCLUDE "./inc/shelf.ini" example

* References


** external
+ my [[http://mcgowans.org/marty3/commonplace/][Commonplace Book]]
+ the [[./combine.org][Combine facility]]

** SHELF local
+ the [[./shelf.org][SHELF Standard]]
+ the [[./README.org][Shelflib -- User Guide]]
+ the [[./famguide.org][fam function family]]
+ the [[./shdoc.org][shdoc function family]]
+ the [[./trace.org][trace function family]]
+ the [[./utilguide.org][utility function group]]

#+INCLUDE: ./author.org
