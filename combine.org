#+INCLUDE: ./universalOrgPreface.org

#+TITLE: CombineLib

* COMMENT hidden from document
    ---
** DONE cleanup tanglelib
   Closed: [2016-04-25 Mon 10:05]

** TODO extend report_notcalleby to accept multiple function arguments
** DONE factor installation out of combining
   CLOSED: [2016-05-26 Thu 11:31]
** TODO then, add installation in each major tangler

** DONE move from tangle to COMBINE
   CLOSED: [2016-05-26 Thu 11:30]
** DONE add combine_mkapp, combine_mksh
   CLOSED: [2016-05-17 Tue 11:23]

* Combine and Install Introduction 

This  paper is  part of  my [[http://mcgowans.org/marty3/commonplace][Commonplace  Book.]] It  introduces a  shell
function library, *combinelib*.  This  function library allow users to
compose files  from reusable  smaller files,  combine them  in various
methods, and install those combinations in a run-time environment.

If necessary, the user may have  to supply an intermediate toolkit if,
for  example   /compiling/  is  required.   Otherwise,   for  all-text
situations, this library is a complete package.

The  library  contains functions  from  the  [[./shelf.org][SHELF Standard]].   In  the
language of  that standard, two  families *combine* and  *install* are
presented.  A  function family  has a parent  function, any  number of
sub-functions, and  like-named variables.   For example  the *combine*
family   has   a   function  named   ~combine~   and   ~combine_init~,
~combine_one,~   ...    and   shell  variables   named   COMBINE_FROM,
COMBINE_TO, and so forth.

The  /combine/ functions  combine individual  file fragments  from the
COMBINE_FROM  directory, defaulting  to  ~./inc~  into the  COMBINE_TO
directory,  defaulting  to ~./src~  from  which  they may  be  further
optionally compiled and installed into run-time locations.

The /install/ tools  install tools from the  INSTALL_FROM directory to
the INSTALL_TO directory, whether /combined/ or not.

The shell variables  default to make the  process seamless: COMBINE_TO
and INSTALL_FROM are the same location.

A bootstrap is also supplied.   Once the *combinelib* is installed by
the bootstrap, it is ready for use in other cases.

* Usage, operations

These are in sequence, since combining occurs before installation.

The user finds the components in  their respective
places in the [[https://github.com/applemcg/shelf][github repo: shelf]].

#+BEGIN_EXAMPLE

 COMBINE, followed by INSTALL
 ----------------------------

       inc/~.all
       ---------
           + <------+ @ file
           V        + @ file
      ( COMBINE )   + ...
           | 
           V
       src/~.out
       ---------
           + <---| src/~.install
           V
      ( INSTALL ) 
           |
           V
       ---------	 
      INSTALL_OUT/~

#+END_EXAMPLE

This companion table shows how default suffix and directory names
are mapped onto shell variables. 


  | pref       | COMBINE | INSTALL |
  |------------+---------+---------|
  | directory: |         |         |
  |------------+---------+---------|
  | inc        | _FROM   |         |
  | src        | _TO     | _FROM   |
  |------------+---------+---------|
  | suffix:    |         |         |
  |------------+---------+---------|
  | all        | _SRC    |         |
  | out        | _OUT    | _SRC    |
  | install    |         | _CMD    |

For  example   COMBINE_TO  and  INSTALL_FROM  both   share  the  /src/
directory.  And /install/  is the name of an  INSTALL_CMD suffix.  All
may be customized.

** combine

*** files

From a file named /something/.all, where *all* is the default for *COMBINE_SUF*,
with zero or more recursive ~@include~ directives, produce /something/.out,
where *out* is the default for *COMBINE_OUT*

Here's a sample input file
: @include aux.0
: @include aux.1
:  ...
: @include report.all
: @include stack.0
: @include trace.0
:  ...

*** commands

Run either  of these  commands to  combine the  file fragments  into a
useful file:

: $ include file.${COMBINE_SUF} > file.${COMBINE_OUT} 2> file.err
: $ combine_mk       # in the parent directory of COMBINE_ALL

** install

Installation happens from the  INSTALL_FROM directory.  It's default is
the COMBINE_TO directory.   It may be as simple  as ~./src~, relative
to  the current  directory.  Files  in  that directory  named with  an
INSTALL_CMD suffix,  defaulting to  *install* direct  the installation
process.   Files with the suffix INSTALL_SRC are moved (linked, copied)
as executable to either, in order:
1. the INSTALL_TO directory, if set, 
1. a previously installed executable location:  ~which file~, or
1. the user's HOME/bin
An non-existent  installation directory is gratuitously  created if it
does not previously exist.

*** a file

An installation file looks like:
: install_bin combine
: install_app include

Where    the   available    user    commands    are   the    functions
*install_{bin,app}*,   where  the   _bin   installs   /file/  in   the
INSTALL_TO/{file}lib. The _app command  installs the file directly in
the  INSTALL_TO/file.  An  /app/  is a  script  or other  executable,
whereas a  /bin/ is really  a shell  library.  The /lib/  directive is
reserved for  future expansion  where a  file may  need to  be linked,
moved, or copied to the run-time environment's ~/lib~ directory.

*** the commands

If using both /combine/ and /install/ features, from the parent directory
from the _INC and _SRC directories, then:

: $ source combinelib # once in the terminal session, and 
:   ...               # anytime later
: $ install_combine   # installs the combine result

Or if just using the installation by itself

: $ install_one  name # from name.install

** conventions

Some conventions are required:

+ the installation location is
    - INSTALL_TO
    - an existing executable file on the user's PATH
    - HOME/bin
    - if neither exist prior to installation, they are created just in
      time.

+ the command

  : $ install_combine

does the  combining and  installing, given appropriate  file fragments
and install scripts.   There may be multiple  installations per source
directory.  On  the other hand.   Since there is only  one destination
base per  install file, multiple  installation targets may  be managed
from the same sources.   See the customization below.


+ master files have a unique suffix, COMBINE_SUF, defaulting to  *all*

+ the combined product has a unique suffix, COMBINE_OUT, defaulting to
  *out*

+ in all cases, the suffix for error files (stderr) is *.err*

+ there is  no requirement (other than good taste)  on other prefix or
  suffix names.  In  this sense, "good taste" includes  the concept of
  no spaces in a file name

* Combine Code
 
The /combine/ code comes in two pieces:

1. the workhorse  is the *include* script,  which recursively includes
   named file fragments into a master file.

1.  a  small  function   family:  *combinelib*,  providing  name-space
   management with shell variables while wrapping the include process.

** installation

This fragment combines (!) the /combine/ and /install/ families into a
single library  *combinelib*.  Since a  first-time user will  not have
the  library  already  installed, the  simple  bootstrap  instructions
follow, which should add to one's appreciation of the method.

The ~install_bin~  command anticipates  an output  file: /combine.out/
and looks  for or  creates a  *bin* directory  to hold  the executable
*combinelib*

Moreover,  this  distribution includes  a  copy  of necessary  utility
functions from the [[http://mcgowans.org/marty3/commonplace/software/shelf.html][SHELF]] Standard.  At some glorious future date, this
will incorporate sourcing that library,  rather than having copied its
code, as a prerequisite.

#+INCLUDE: "./src/combine.install" example

** include

The include script.  Look for an /iawk/ or [[https://www.mankier.com/1/igawk][gawk]] reference on the web.
The simple syntax is:
: @include filename
and it is recursive.   

This file needs no combining.  It is a shell script.

#+INCLUDE: "./inc/include.all" example

** combine family
The *combinelib*  is built in  a few  pieces.  First is  the copyright
notice and an entry-point, main function.
*** combine_mk

This is the top /combine/ function.

#+INCLUDE: "./inc/combine.0" example

The *combine_bunch* function leaves it's output on ~stdout~, where it's
used as the file-name argument to *mv_orrm* (move or remove) to the second,
directory argument.

*** combine functions

This is the remainder of the *combinelib* function library.

Other, copied utility functions follow.

The manual procedure to collect those functions is also being
formalized with functions and a library.

#+INCLUDE: "./inc/combine.1" example

*** combine combined
#+INCLUDE: "./inc/combine.all" example

While this is a good rule, occasionally it may be broken.

: each file should have one syntax, either include or script.

* Install Code

The  /install/ family  is  initially installed  here  by a  boot-strap
process.  Failing to find an already installed library or application,
this installation  creates an  *INSTALL_TO* directory,  defaulting to
~HOME/bin~ if it doesn't exist, otherwise links the executable library
or application to that directory.

Since  this process  now adheres  to  the combining  process, it  uses
conventions established there, and adds just a few of its own.

** install installation

Install  is now  part  of the  /combine/ family;  it  has no  separate
installer.   And its  combining is  done together  with the  /combine/
family as part of the *combinelib*.

** testboot.sh

One's work should  always have a large  [[https://en.wikipedia.org/wiki/Chicken_or_the_egg][chicken-or-egg]] component.  So,
the bootstrap process to install the installation code is:

#+INCLUDE: "./testboot.sh"  example

** bootstrap.sh

#+INCLUDE: "./bootstrap.sh" example

** instructions

1. inspect, if  necessary, edit the bootstrap  script, particularly to
   set the  location of the INC  and SRC directories, the  SUF and OUT
   file suffixes, corresponding to your own choices.  
1. from the shell, do the bootstrap combining
   : . ./bootstrap.sh
   creates  *.out* files  from *.all*  and sources  workable functions
   into the current shell
1. you are instructed to run this command, which you may do at will.
   : $ compile_install

This may have to be repeated as functions are added here.  Routinely, 
the installation here, as elsewhere is:

: $ combine_mk
: $ indir src source {libname}.install

is now shortened to:

: $ install_combine

The  combining  facets  have  been  factored out.   The  code  in  the
COMBINE_FROM  directory  may   be  treated  as  the   native,  raw,  or
version-controlled components.  This requires accommodations:

1. ability to  re-target or re-host the code has  been accomplished by
   use of the COMBINE_FROM and COMBINE_TO shell variables.

1. separate any wrong-way tools connections from a *combinelib* and an
   *installlib*.   Either  that,  or  combine  the  two  libraries  as
   families in a single lib.

Once manually  installed, the re-installation script  is the prototype
for any  other code.   This installation format  also respects
the first requirement above.

*** install install

** Install Code

The ~install_combine~ function  is only useful for code,  such as this
which has  been produced by 
any text editor where  the development environment has access to
the [[../combine/combine.org][combinelib]].   The products  of the  ~combine_all~ step  become the
general user source view of the components.

*** User Functions

#+INCLUDE: "./inc/install.0" example

*** Family Functions

#+INCLUDE: "./inc/install.1" example

* User Customization
A user who wants to customize the COMBINE variables need only assign
them before sourcing the ~combinelib~, for example:
#+BEGIN_EXAMPLE

    COMBINE_FROM=../include
    COMBINE_TO=../src
    COMBINE_SUF=txt       # no "." in suffix names
    COMBINE_OUT=out       # same as default for clarity
    source combineline    # new variables apply
   
#+END_EXAMPLE

* Reported errors

+ combine_mk
    1. internal function called manually
    1. internal function called with insufficient arguments
    1. internal function called with non-file argument

+ include
    1. writes list of un-found files in the *include.not* file

* Rationale

These  functions were  originally built  to simplify  the products  of
/tangling/, or [[http://orgmode.org/org.html#Specific-header-arguments][extracting source code]] from an OrgMode source file.




With the  idea of  sharing on [[http://github.com/applemcg/shelf][Github: applemcg/shelf]],  the
fragments had  to fit a  generally-accessible framework. Thus  was born
the notion of the directory and file-suffix naming conventions.

Not every /combined/ file
may change.  The modification time  on a COMBINE_OUT file is unchanged
if its contents are unchanged.

Originally the two families were  separate libraries.  I combined them
for a few reasons:

1. to test the notion a library with a single function family may join
   with another, closely related family.
1. to  discover how difficult it  was to add seams:  here for example,
   rather than have  a single name for the products  of combination to
   be stuff to install, split the  name to allow use of either package
   without  the  other.   specifically have  INSTALL_FROM  default  to
   COMBINE_TO.
1.  to  eliminate redundant  use  of  many  functions from  the  [[http://mcgowans.org/marty3/commonplace/software/shelf.html][SHELF
   Standard]].   And  this motivates  a  piece  of  the practice:  in  a
   library-rich  environment,  have  a  process  which  picks  up  the
   disparate functions into a  single library or application depending
   on  no other  function  libraries, and  needs only  system-supplied
   tools.  Tools to do this discovery are in *applib*

And I've discovered a saying: /It takes two to TANGLE/

* COMMENT Lessons 						     :tangle:

I've learned, of historical note, and needs revision.

With this file, I've learned how to have code live with it's documentation, and
almost install it.  That lesson awaits understanding how to hang a "hook" while
[[http://orgmode.org/manual/Extracting-source-code.html#Extracting-source-code][extracting the source code]].  

Here are the steps I go thru:
1. edit the code or it's documentation. (may use C-c ' in a code block),
1. "tangle" the code block(s) -- see the link above, which ship the code off
   to it's place to live.
1. execute the 'installation' instructions below. these are only 
   in the Org file, since they're hidden from the HTML output.
   alternatively, do the same thing from a terminal window, where
   the commands may be tested independently of emacs/OrgMode.

Hanging the hook: /org-babel-post-tangle-hook/ promises to allow
post-processing, i.e. making the ../bin files executable and linking
the text files to the adjacent ../lib directory.

And, just maybe, this should become the ASSERTlib, change every instance
of report_ to assert_?

* COMMENT Commands

** information

: $ combine_all
: $ indir .untangle . tangle.install

OR
: $ install_tangle

and remember tangle command : C-c C-v t

* References

+ my [[http://mcgowans.org/marty3/commonplace/][Commonplace Book]]
+ the [[./combine.org][Combine facility]]
+ the [[./shelf.org][SHELF Standard]]
+ the [[./README.org][Rationale and Practice]]
+ the [[./famguide.org][fam function family]]
+ the [[./shdoc.org][shdoc function family]]
+ the [[./trace.org][trace function family]]
+ the [[./utilguide.org][utility function group]]

