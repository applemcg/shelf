UC () 
{ 
    : file STDIN;
    : arguments minimum 0;
    : returns list in UPPER CASE;
    : optional command arguments are folded otherwise stdin;
    [ $# -gt 0 ] && { 
        echo $* | tr a-z A-Z
    } || { 
        cat - | tr a-z A-Z
    }
}
comment () 
{ 
    echo $* 1>&2
}
functionsn () 
{ 
    : date 2016-10-27;
    : date 2016-11-03;
    : date 2016-11-13;
    funct_list $* | printfirst
}
printfirst () 
{
    : ~ STDIN or file ...
    : lists line with first INSTANCE of first FIELD 
    trace_call $*;
    awk '!printed [$1]++' $*
}
ignore () 
{
    : ~ cmmd args ...
    : returns STATUS, but not STDOUT
    $@ > /dev/null
}
quietly ()
{
    : ~ cmmd args ...
    : returns STATUS, but not STDERR
    $@ 2>/dev/null
}
isfunction () 
{
    : ~ function
    : returns TRUTH of argument as FUNCTION
    declare -f $1 > /dev/null
}
myname () 
{
    : ~ [n]
    : returns name of caller OR callers caller ...
    echo ${FUNCNAME[${1:-1}]}
}
setenv () 
{
    : ~ NAME value ...
    : exports NAME to the environment,
    : set to value ...
    [[ $# -lt 1 ]] && return;
    local na=$1;
    shift;
    eval $na=\"$*\";
    export $na
}
sfg () 
{
    : ~ [pattern]
    : Set Functions Grep pattern
    : returns FUNCTIONS in current ENVIRONMENT with pattern
    : e.g.   sfg PIPE wc   counts number of functions
    trace_call $*;
    set | functions | grep -i ${*:-.}
}
funct_list () 
{ 
    : date 2016-11-13;
    spaceit $* | awk '$2 ~ /^\(\)$/ {print $1}'
}
spaceit () 
{ 
    : anagram of letters in set, pipe, cat;
    : date 2016-10-27;
    : date 2016-11-03;
    : date 2016-11-12;
    function ispipe () 
    { 
        [[ -p /dev/stdin ]]
    };
    case $# in 
        0)
            ispipe && cat || set
        ;;
        *)
            cat $*
        ;;
    esac
}
fix_debug () 
{ 
    : looks more like trace_stderr;
    : read_tty IS _off;
    local nf=${#FUNCNAME[@]};
    local gr=$(myname 3);
    local pa=$(myname 2);
    printf "DEPTH %d\t%s\t%s\t#: %d\t%s : " $nf $gr $pa $# "$*" 1>&2;
    read x < /dev/tty
}
notfunction () 
{ 
    : date 2016-12-03;
    isfunction $1 || echo $1
}
ymd_hms () 
{ 
    : date: 2017-05-29;
    trace_call $*;
    date "+%Y_%m%d_%H%M%S${1:+ $*}"
}
