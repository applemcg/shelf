# SHD family

# The functions here operate on  shell functions, and operate similar to
# the  three mentioned  above: Java,  Perl,  and Python.   The two  most
# useful functions, *shdoc* and *shd_with* produce a function whose body
# is  the collected  comments in  what  I'm calling  *shdoc*, or  /shell
# doclib comment/ format:
shd_copyright () 
{ 
    comment "Copyright (C) 2016, JYATL - Just Yet Another Testing Lab";
    comment "mailto: mcgowan (at) alum DOT mit DOT edu"
}
shd_init ()
{
   fam_iam
}
shdoc () 
{ 
    : this is a shell doclib "shdoc" comment;
    : an shdoc comment is the first ":"-origin lines;
    : in the shell function, the rest being the executable.;
    for f in ${*:-$(myname)};
    do
        shd_each $f;
    done
}
shd_with () 
{ 
    : removes shd_less functions from shdoc results;
    : creating function {name}_doc for function "name";
    shdoc $* | awk '
    #                 { print "DEBUG: ", fcount, last > "/dev/stderr"; }
    $1 ~ /function/   { fcount++; last = $0; next;  }
    $1 ~ /}/ && last  { next }
    last              { print last; last = ""; fcount = 0;  }
    fcount == 0       { print }
                   '
}
shd_each () 
{
    report_notfunction $1 && return 1;
    report_notcalledby shdoc && return 2;
    trace_call $*;
    echo "function ${1}_doc {";
    declare -f $1 | awk '
       NR > 2 {
                if ( $1 !~ /^:/ ) exit
                else              print
              }
        ';
    echo "}"
}
shd_oc () { shdoc $@; }
shd_trim () 
{
    : ~ function
    : user function to show candidate comments
    report_notfunction $1 && return 1;
    trace_call $*;
    declare -f $1 | awk ' $1 !~ /^:$/'
}
# utility functions
   
# Note the shell idiom in the *shd_top* function.   It's a convenient 
# shorthand to list a collection of similar names.  In this case, this
# SHD family conventionally defines functions whose name begins with shd_.
shd_top () 
{ 
    echo shdoc shd_{oc,each,with,test}
}
shd_test () 
{ 
    : 1. test default, NO arguments, then;
    : 2. stub out test all functions in the library;
    : 3. demonstrate ignore subsequent comments;
    : 4. test shd_with;
    : 5. test shd_each defends against non-shdoc call;
    shdoc;
    :;
    set $(sfg shd_);
    : doit shdoc $*;
    shd_with $*;
    shd_each $*;
    declare -f shd_test | grep -v '^ *:' 1>&2
}
shd_assert () 
{ 
    : ~ function;
    : returns: candidate comments;
    : turns report_not... into colon-comment for docstring.;
    : uses: shd_justcolon sed;
    report_notfunction $1 && return 1;
    trace_call $*;
    declare -f $1 | sed 's/^\( *\)\(report_not\)/\1: \2/' | shd_justcolon
}
shd_clean () 
{ 
    : removes empty doc strings from stdin;
    report_notpipe && return 1;
    awk '
        # !NF             { next }
        #                 { printf "DEBUG: NR(%d), fc(%d): %s\n", NR, fcount, last > "/dev/stderr"; }
        $1 ~ /function/   { fcount++; last = $0; next;  }
        $1 ~ /}/ && last  { next }
        last              { print last; last = ""; fcount = 0;  }
        fcount == 0       { print }
    '
}
shd_demo () 
{ 
    shdoc $(sfg shd_)
}
shd_justcolon () 
{ 
    report_notpipe && return 1;
    awk '
	   NR > 2 {
               if ( $1 !~ /^:/ ) exit
	       else              print
           }
        '
}
shd_one () 
{ 
    : date 2017-02-09;
    : this is a shell doclib "shdoc" comment;
    : --------------------------------------;
    : an shdoc comment is the first ":"-origin lines;
    : in the shell function, the rest being the executable.;
    : writes a function {name}_doc for function "name";
    : note: "function NAME_doc () {" is a sticky format.;
    : uses: shd_trim;
    report_notfunction $1 && return 1;
    printf "function %s_doc () {\n" $1;
    shd_trim $1;
    echo "}"
}
shd_tagnames () 
{ 
    : date: 2017-04-19;
    report_notfunction $1 && return 1;
    shd_tags $* 2> /dev/null | field 2 | sort -u
}
shd_tags () 
{ 
    : args: function ...;
    : format: function tag-line;
    : uses: shd_oc awk;
    shd_oc $* | awk '

        $1 ~ /^function$/ { name = $2; sub(/_doc$/,"",name); }
	$2 ~ /:$/         {
           tag = $0
	   sub(/: /,"",tag)
   	   sub(/: /,"\t",tag)
      	   sub(/;$/,"",tag)
	   printf "%-9s\t%s\n", name, tag
        }
	'
}
