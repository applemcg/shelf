# needed library functions
# [[file:~/Dropbox/commonplace/software/applib.org::*needed%20library%20functions][needed\ library\ functions:1]]
c_fun_extract () 
{ 
    trace_call $*;
    declare -f $* | awk '$1 !~ /^:$/' | tr '(){};,/*$' '         ' | tpl | sort -u | grep '^[a-zA-Z0-9_]'
}
cmd () 
{ 
    fam_generic cmd $*
}
comment () 
{ 
    echo $* 1>&2
}
for_nomar () 
{ 
    : continue executing first arg as command,;
    : until number of returned arguments is unchanged.;
    while true; do
        comment NOMAR $# $*;
        num=$#;
        set $1 $($*);
        echo $*;
        [[ $num -eq $# ]] && break;
        read a;
    done
}
foreach () 
{ 
    report_notcommand $1 && return 1;
    typeset cmd=$1;
    shift;
    for arg in "$@";
    do
        $cmd $arg;
    done
}
fun_extract () 
{ 
    trace_call $*;
    c_fun_extract "$@"
}
fun_from () 
{ 
    trace_call $*;
    : reconcile patterns to fuse;
    cat ${*:--} | awk ' 
        $2 ~ /^\(\)$/     { print $1 } 
             /^function / { print $2 }
    '
}
fun_uses () 
{ 
    trace_call $*;
    foreach type_me $(foreach fun_extract $* | sort -u) | awk '

        $1 ~ /^function$/ {print $2}
    '
}
functions () 
{ 
    trace_call $*;
    fun_from $* | printfirst
}
ignore () 
{ 
    $@ > /dev/null
}
isfunction () 
{ 
    trace_call $*;
    declare -f $1 > /dev/null
}
myname () 
{ 
    echo ${FUNCNAME[${1:-1}]}
}
needfrom () 
{ 
    : ~ library functions ...;
    : now it blythlyt "source"s the library and simply tests;
    : for functions existance;
    local lib=$(which $1);
    shift;
    report_notfile $lib && return 1;
    trace_call $*;
    local fun;
    source $lib;
    for fun in $*;
    do
        report_notfunction $fun && return 2;
    done
}
printfirst () 
{ 
    trace_call $*;
    awk '!printed [$1]++' $*
}
qmoved () 
{ 
    [ "$PWD" == "${1:-$PWD}" ] && return;
    echo MOVED to $PWD
}
setenv () 
{ 
    [[ $# -lt 1 ]] && return;
    local na=$1;
    shift;
    eval $na=\"$*\";
    export $na
}
sfg () 
{ 
    trace_call $*;
    set | functions | grep -i ${*:-.}
}
source () 
{ 
    set $1 $(basename $1);
    set $1 ${2%lib};
    trace_call $*;
    isfunction ${2}_init && { 
        comment SOURCE ${2}lib has been sourced, unset ${2}_init to source;
        return
    };
    local f;
    case $1 in 
        */*)
            f=$1
        ;;
        *)
            f=$(which $1)
        ;;
    esac;
    case $f in 
        "")
            comment NO $1 in PATH;
            return
        ;;
    esac;
    save_dir=$PWD;
    [[ -f $f ]] && command source $f;
    : manual PPTLOG:;
    date "+%F %a %b %d %T SOURCEd $f from $save_dir $(qmoved $save_dir)" >> ~/lib/source.log
}
tpl () 
{ 
    trace_call $*;
    cat ${*:--} | tr -s ' \t' '\n'
}
trace_call () 
{ 
    return
}
trace_stderr () 
{ 
    pa=${FUNCNAME[2]:-COMMANDLINE};
    gr=${FUNCNAME[3]:-COMMANDLINE};
    printf "TRACE %s\t@ %s %d  ( %s )\n" "$pa" "$gr" $# "$*" 1>&2
}
type_me () 
{ 
    printf "%s\t%s\n" $(type -t $1) $1
}
wpl () 
{ 
    trace_call $*;
    cat ${*:--} | tr -cs 'A-Za-z0-9_' '\n'
}
# needed\ library\ functions:1 ends here
